"""
AI Teach Command - IDE-native teaching interface
Handles /teach commands for explaining errors, concepts, and code
"""
import sys
import sqlite3
from pathlib import Path
import json

DB_PATH = Path(__file__).parent.parent / '.ai_coach' / 'progress.db'
CONFIG_PATH = Path(__file__).parent.parent / '.ai_coach' / 'config.json'
PROFILE_PATH = Path(__file__).parent.parent / '.ai_coach' / 'user_profile.json'

def load_config():
    """Load configuration"""
    if CONFIG_PATH.exists():
        return json.loads(CONFIG_PATH.read_text(encoding='utf-8'))
    return {}

def teach_last_error():
    """Show and explain last error"""
    conn = sqlite3.connect(str(DB_PATH), timeout=30)
    cur = conn.cursor()
    
    cur.execute("""
        SELECT file_path, line_number, error_type, error_message, lesson_created, timestamp
        FROM errors_log
        WHERE resolved = 0
        ORDER BY timestamp DESC
        LIMIT 1
    """)
    
    row = cur.fetchone()
    if not row:
        print("‚úÖ No recent errors found!")
        conn.close()
        return
    
    file_path, line_num, error_type, message, lesson_id, timestamp = row
    
    print(f"\nüî¥ Last Error ({timestamp}):")
    print(f"   File: {file_path}:{line_num}")
    print(f"   Type: {error_type}")
    print(f"   Message: {message}\n")
    
    if lesson_id:
        # Show saved lesson
        cur.execute("SELECT title, obsidian_path FROM knowledge_extracts WHERE id = ?", (lesson_id,))
        lesson = cur.fetchone()
        if lesson:
            print(f"üìö Lesson: {lesson[0]}")
            print(f"   Path: {lesson[1]}\n")
            
            # Show content
            lesson_path = Path(lesson[1])
            if lesson_path.exists():
                content = lesson_path.read_text(encoding='utf-8')
                print("=" * 60)
                print(content)
                print("=" * 60)
    else:
        print("‚ö†Ô∏è  No lesson created yet for this error.")
        print("   AI should analyze and create lesson.")
    
    conn.close()

def teach_concept(concept_name: str):
    """
    Teach a concept with v3.0 enhancements:
    - Personalized analogy (if user has profile)
    - ROI info (if it's a skill)
    - BKT mastery tracking
    """
    print(f"\nüìñ Teaching: {concept_name}")
    print("=" * 60)
    
    # 1. Show personalized analogy (v3.0)
    try:
        from analogy_generator import generate_analogy
        analogy_result = generate_analogy(concept_name)
        if analogy_result and not analogy_result.get('cached'):
            print(f"\nüí° Analogy ({analogy_result['source_domain']}):")
            print(analogy_result['analogy'])
            print()
    except Exception as e:
        print(f"‚ö†Ô∏è  Analogy generation skipped: {e}")
    
    # 2. Show ROI if it's a skill (v3.0)
    try:
        from skill_roi_calculator import calculate_roi
        roi = calculate_roi(concept_name, use_cache=True)
        if roi.get('status') != 'error':
            print(f"\nüí∞ Skill ROI Analysis:")
            print(f"   ROI Score: {roi['roi_score']:,.0f}")
            print(f"   Market Salary: ${roi['market_salary']:,}")
            print(f"   Learning Time: ~{roi['hours_estimate']:.0f} hours")
            print(f"   {roi['recommendation']}")
            print()
    except Exception:
        pass  # Not all concepts are skills
    
    # 3. Check current mastery (v3.0 BKT)
    try:
        conn = sqlite3.connect(str(DB_PATH), timeout=30)
        cur = conn.cursor()
        cur.execute("SELECT mastery_prob, attempts FROM skill_mastery WHERE skill_name = ?", (concept_name,))
        result = cur.fetchone()
        if result:
            mastery, attempts = result
            print(f"\nüìä Your Progress:")
            print(f"   Mastery: {mastery:.0%}")
            print(f"   Practice attempts: {attempts}")
            print()
        conn.close()
    except Exception:
        pass
    
    print("üìö Full explanation would be generated by AI Agent here.")
    print("   To get detailed explanation, ask AI Agent directly.")
    print("=" * 60)

def teach_file(file_path: str, line_number: int = None):
    """Show file insights and optionally explain specific line"""
    from file_tracker import get_file_insights
    
    insights = get_file_insights(file_path)
    
    print(f"\nüìä File Insights: {file_path}")
    print(f"   Opened: {insights['opened_count']} times")
    print(f"   Errors: {insights['error_count']}")
    print(f"   Lessons: {len(insights['lessons'])}\n")
    
    if insights['lessons']:
        print("   üìö Lessons from this file:")
        for lesson in insights['lessons']:
            print(f"      - {lesson['title']} ({lesson['topic']})")
        print()
    
    if insights['errors']:
        print("   ‚ö†Ô∏è  Error history:")
        for err in insights['errors'][:3]:
            status = '‚úì' if err['resolved'] else '‚úó'
            print(f"      {status} {err['type']}: {err['message'][:50]}...")
        print()
    
    if line_number:
        print(f"   üîç Code at line {line_number}:")
        print("      [AI would analyze code context here]")

def main():
    """
    CLI: python Scripts/ai_teach.py <command> [args]
    """
    import argparse
    
    parser = argparse.ArgumentParser(description='AI Teach - IDE-native teaching')
    parser.add_argument('command', choices=['error', 'concept', 'file', 'insights'])
    parser.add_argument('arg', nargs='?', help='Concept name or file path')
    parser.add_argument('--line', type=int, help='Line number for file command')
    
    args = parser.parse_args()
    
    if args.command == 'error':
        teach_last_error()
    
    elif args.command == 'concept':
        if not args.arg:
            print("Error: concept name required")
            return 1
        teach_concept(args.arg)
    
    elif args.command in ['file', 'insights']:
        if not args.arg:
            print("Error: file path required")
            return 1
        teach_file(args.arg, args.line)
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
